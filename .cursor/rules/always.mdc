---
description: 
globs: 
alwaysApply: false
---
# j4pp - AI Assistant Overview

## Project Overview

**j4pp** is a modern, type-safe full-stack web application template optimized for rapid development and AI workflows. It provides a complete foundation for building web applications with end-to-end type safety from database to frontend.

## Tech Stack

- **Frontend**: Next.js 15, React 19, TypeScript, Tailwind CSS
- **Backend**: Next.js API routes, tRPC for type-safe APIs
- **Database**: PostgreSQL (Neon), Kysely ORM
- **Schema Management**: Atlas (declarative migrations)
- **Authentication**: Clerk
- **State Management**: TanStack Query (React Query)
- **UI Components**: Shadcn/UI, Radix UI
- **Package Manager**: Bun
- **Runtime**: Node.js

## Architecture Overview

### Type Safety Flow

```
Database Schema (db/schema.sql)
    ↓ Atlas applies migrations
PostgreSQL Database
    ↓ Kysely generates types
TypeScript Database Types (src/lib/db-types.ts)
    ↓ tRPC uses for API
Type-safe API Routes
    ↓ React components consume
Frontend with full type safety
```

### Key Directories

- `src/app/` - Next.js App Router pages and API routes
- `src/components/` - React components and UI library
- `src/server/` - tRPC server setup and routers
- `src/lib/` - Database connection and utilities
- `db/` - Database schema and migrations
- `scripts/` - Setup and utility scripts

## Development Patterns

### 1. Database Changes

**Location**: `db/schema.sql`
**Process**:

1. Edit the declarative schema in `db/schema.sql`
2. Run `bun run db:setup` to apply changes and regenerate types
3. Types automatically flow through the entire application

**Example Schema**:

```sql
create table users (id serial primary key, clerk_user_id text);
```

### 2. Database Operations with Kysely

**Location**: `src/lib/db.ts` (database connection), use in tRPC procedures
**Types Source**: `src/lib/db-types.ts` - **This is the source of truth for all database types**
**Patterns**:

- Import the `db` instance from `src/lib/db.ts`
- Use generated types from `src/lib/db-types.ts` - **always reference this file for current table/column types**
- Full type safety with autocomplete for table names and columns
- Support for complex queries, joins, and transactions

**Important**: The `src/lib/db-types.ts` file is auto-generated by Kysely and contains all your database table definitions as TypeScript interfaces. When you modify `db/schema.sql` and run `bun run db:setup`, this file is automatically updated. **Never edit this file manually** - it's your source of truth for all database types.

**Example Database Operations**:

```typescript
import { db } from '@/lib/db';

// Simple queries
const allUsers = await db.selectFrom('users').selectAll().execute();
const user = await db
  .selectFrom('users')
  .where('id', '=', 1)
  .selectAll()
  .executeTakeFirst();

// Insert operations
const newUser = await db
  .insertInto('users')
  .values({
    clerkUserId: 'clerk_user_123',
  })
  .returningAll()
  .executeTakeFirst();

// Update operations
const updatedUser = await db
  .updateTable('users')
  .set({ clerkUserId: 'new_clerk_id' })
  .where('id', '=', 1)
  .returningAll()
  .executeTakeFirst();

// Delete operations
await db.deleteFrom('users').where('id', '=', 1).execute();

// Complex queries with joins (when you have multiple tables)
const userWithPosts = await db
  .selectFrom('users')
  .innerJoin('posts', 'users.id', 'posts.userId')
  .select(['users.id', 'users.clerkUserId', 'posts.title'])
  .where('users.id', '=', 1)
  .execute();
```

### 3. API Development

**Location**: `src/server/routers/_app.ts`
**Patterns**:

- Use `publicProcedure` for unauthenticated endpoints
- Use `protectedProcedure` for authenticated endpoints
- Input validation with Zod schemas
- Full type safety from database to frontend
- Combine with Kysely for database operations

**Example Router with Database Operations**:

```typescript
import { db } from '@/lib/db';
import { z } from 'zod';
import { publicProcedure, protectedProcedure, router } from '../trpc';

export const appRouter = router({
  getPublic: publicProcedure.query(() => {
    return { message: 'Public data' };
  }),

  getProtected: protectedProcedure.query(async ({ ctx }) => {
    return { userId: ctx.userId, data: 'Private data' };
  }),

  // Database operations examples
  getAllUsers: publicProcedure.query(async () => {
    const users = await db.selectFrom('users').selectAll().execute();
    return users;
  }),

  getUserById: publicProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ input }) => {
      const user = await db
        .selectFrom('users')
        .where('id', '=', input.id)
        .selectAll()
        .executeTakeFirst();
      return user;
    }),

  createUser: protectedProcedure
    .input(z.object({ clerkUserId: z.string() }))
    .mutation(async ({ input, ctx }) => {
      const user = await db
        .insertInto('users')
        .values({ clerkUserId: input.clerkUserId })
        .returningAll()
        .executeTakeFirst();
      return user;
    }),

  updateUser: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        clerkUserId: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      const user = await db
        .updateTable('users')
        .set({ clerkUserId: input.clerkUserId })
        .where('id', '=', input.id)
        .returningAll()
        .executeTakeFirst();
      return user;
    }),
});
```

### 4. Frontend Development

**Location**: `src/app/` and `src/components/`
**Patterns**:

- Use functional React components (not arrow functions)
- tRPC hooks for type-safe API calls: `api.endpointName.useQuery()`
- Clerk components for authentication
- Tailwind CSS for styling

**Example Component**:

```typescript
function MyComponent() {
  const query = api.getProtected.useQuery();

  return (
    <div className="bg-background">
      {query.data && <p>{query.data.message}</p>}
    </div>
  );
}
```

### 5. Authentication

**Provider**: Clerk
**Integration**:

- Wrapped in `ClerkProvider` in layout
- `SignedIn`/`SignedOut` components for conditional rendering
- `UserButton` for user management
- tRPC context includes `auth` and `userId`

## Key Commands

```bash
# Full setup (creates DB, applies schema, generates types)
bun run setup

# Development
bun run dev

# Database operations
bun run db:setup     # Apply schema + generate types
bun run db:push      # Apply schema to database
bun run db:generate  # Generate types from database

# Environment-specific database pushes
bun run db:push:stage
bun run db:push:prod
```

## Environment Configuration

**Required Environment Variables**:

- `DATABASE_URL` - PostgreSQL connection string
- `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` - Clerk public key
- `CLERK_SECRET_KEY` - Clerk secret key

**Optional**:

- `STAGING_DATABASE_URL` - Staging database
- `PRODUCTION_DATABASE_URL` - Production database

## File Structure Patterns

### Database Layer

- `db/schema.sql` - Declarative schema definition
- `src/lib/db.ts` - Database connection setup
- `src/lib/db-types.ts` - Auto-generated TypeScript types

### API Layer

- `src/server/trpc.ts` - tRPC server configuration
- `src/server/routers/_app.ts` - Main API router
- `src/app/api/trpc/[trpc]/route.ts` - tRPC API endpoint

### Frontend Layer

- `src/app/layout.tsx` - Root layout with providers
- `src/app/page.tsx` - Home page
- `src/components/` - Reusable components
- `src/components/providers.tsx` - tRPC and React Query providers

## Common Development Scenarios

### Adding a New Database Table

1. Add table definition to `db/schema.sql`
2. Run `bun run db:setup`
3. Use generated types in `src/lib/db-types.ts`
4. Create tRPC procedures in `src/server/routers/_app.ts`
5. Use in frontend components with `api.tableName.useQuery()`

### Adding Authentication to an Endpoint

1. Use `protectedProcedure` instead of `publicProcedure`
2. Access `ctx.userId` for user identification
3. Frontend will automatically handle auth state

### Creating New Pages

1. Add files to `src/app/` following Next.js App Router conventions
2. Use `'use client'` directive for client components
3. Import and use tRPC hooks for data fetching
4. Use Clerk components for auth-aware rendering

### Styling Components

1. Use Tailwind CSS classes
2. Leverage Shadcn/UI components from `src/components/ui/`
3. Follow the design system with `bg-background`, `text-foreground`, etc.

## Best Practices

1. **Type Safety**: Always use the generated types from Kysely
2. **Database Changes**: Only modify `db/schema.sql`, never edit generated types
3. **API Design**: Use Zod for input validation, return structured responses
4. **Component Design**: Use functional components, prefer composition over inheritance
5. **Error Handling**: Leverage tRPC's built-in error handling
6. **Authentication**: Use Clerk's components and tRPC's protected procedures
7. **Database Queries**: Use Kysely's type-safe query builder, avoid raw SQL when possible

## AI Development Workflow

When working with this codebase as an AI assistant:

1. **Database Changes**: Always modify `db/schema.sql` and run `bun run db:setup`
2. **API Development**: Add procedures to `src/server/routers/_app.ts`
3. **Frontend Development**: Create components in `src/components/` or pages in `src/app/`
4. **Type Safety**: Leverage the existing type system - don't create manual types
5. **Authentication**: Use existing Clerk integration patterns
6. **Styling**: Use Tailwind CSS and existing Shadcn/UI components
7. **Database Operations**: Use Kysely query builder with generated types for type-safe database operations

This template is designed for rapid iteration and AI-assisted development with minimal configuration and maximum type safety.
